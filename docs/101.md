# Chromatix 101

Here we describe the basic ideas behind chromatix.

## Lightfields

Chromatix's core datatype is the `Field`. The `Field` is a container representing the lightfield, consisting of:

1. The lightfield itself, with shape `[batch x height x width x wavelength]`. When a field gets transformed by an optical element such as a lens or an SLM each batch gets transformed independently. You can use the batch axis for example to work on multiple images at once, or have it act as the depth dimension (the optical axis) when you're working with 3D lightfields.
2. The coordinates of the lightfield, in practice given by the spacing between two grid points. We work with centered grids, meaning we consider `x = y = 0` as the optical axis, and that the field points are defined between `[-N//2, N//2]`.
3. The spectrum and the corresponding spectral density. Currently we only support single-wavelength, but multi-wavelength should hit master soon!

Let's have a look at how this works in practice.

```py
import chromatix.functional as cx
import jax.numpy as jnp

# We first create an empty field. 
field = cx.empty_field((2560, 2560), 1.0, 0.532, 1.0)

# And then turn it into the field generated by a plane wave.
field = cx.planewave(field, )
```

You can access standard properties of lightfields such as their intensity or power:

```py
# Getting the intensity
print(field.intensity) # intensity at each point in the field

# Field power
print(field.power) # returns power in each batch and wavelength
```

We often want to sample or calculate some property at the same grid as the field, for example when applying a phasemask. You can easily acces these grids: 

```py
# Standard x-y grid
print(field.grid) # returns a grid of shape [2, 1, height, width, 1]

# L2 squared grid
print(field.l2_sq_grid) # returns x^2 + y^2 of shape [1, height, width, 1]

```

Additionally, `Fields` have all their standard mathematical operations implemented:

```py
# Adding fields
field = field + field

# Applying some phase change.
phase = jnp.pi / 10 * field.l2_grid 
field = field * jnp.exp(1j * phase)
```

## Optical elements as parametrized transformations

The core idea behind Chromatix is that optical elements perform *parametrized transformations* on lightfields. Code-wise this means that optical elements take in a `Field` as a first argument and an additional number of parameters and return a `Field`. 

Let's take the implementation of a thin lens as an example. 

```py
def thin_lens(field: Field, f: float, n: float, NA: Optional[float] = None) -> Field:
    # We first calculate the quadratic phase change due to the thin lens. 
    L = jnp.sqrt(field.spectrum * f / n)
    phase = -jnp.pi * field.l2_sq_grid / L**2

    # If an NA is given, apply a circular pupil
    if NA is not None:
        D = 2 * f * NA / n  # Expression for NA yields width of pupil
        field = circular_pupil(field, D) # circular pupil here also returns a field!

    # return the field with the phase change
    return  field * jnp.exp(1j * phase)
```

We can use our lens with the `field` we created in the previous section:

```py
# Thin lens with focal distance 10, refractive index 1.33 and NA 0.8
field = thin_lens(field, 10.0, 1.33, 0.8)
```

All optical elements under `chromatix.functional` follow this approach. We've implemented several different lightfield sources (pointsource, planewave, ...), lenses (thin lens, ff lens, ...), and diffraction propagators (transfer method, exact method, ...) and more. See our API for the full list.

An important remark is that we require the functions to be *functional* (as implied by the name :-)). This means that the output field may only depend on the inputs to each function; there can be no hidden internal state. A functional approach is required for Jax (and differentiable programming in general), and makes messing around in Jupyter notebooks a lot easier. 


!!! tip
    This also makes it straightforward to implement new elements: they just need to be function whose first input is a `Field` and they must return a `Field` - what you do inbetween is up to you. 

## Elements and Optical Systems

The functional interface quickly becomes cumbersome when you're building larger models with several elements you want to optimize. To deal with this we've build a more classical deep-learning style `chromatix.elements` API where each optical element is a [Flax](https://flax.readthedocs.io/en/latest/) `Module`. We highly recommend reading the [Flax tutorial](https://flax.readthedocs.io/en/latest/guides/index_flax_fundamentals.html) before reading this section.

As an example, let's use the thin lens from the previous section again:

```py
import chromatix.elements as ce
from jax import random

key = random.PRNGKey(42)

# Thin Lens
model = ce.ThinLens(10.0, 1.33, 0.8)
params = model.init(key, field) # initializing parameters of model
field = model.apply(params, field)

print(params) # empty dict
```

When we print the `params` we that it's an empty dictionary, meaning that we're not optimizing any of the parameters of `ThinLens`. We use simple pattern to decide which parameters are optimizable: 

** To make a parameter trainable, it should be a function with an rng key as input and the initial value as output.**

A few examples:

```py
# Focal distance is trainable, random init
model = ce.ThinLens(lambda key: 10 * random.uniform(key), 1.33, 0.8)

params = model.init(key, field)
print(params)

# Refractive index is trainable, fixed init 
model = ce.ThinLens(10.0, lambda _: 1.33, 0.8)

params = model.init(key, field)
print(params)
```

A model consisting of just a thin lens isn't very interesting. To chain multiple elements together into a single optical system, you can use `OpticalSystem`:

```py
from chromatix import OpticalSystem

model = OpticalSystem([ce.PlaneWave((2560, 2560), 1.0, 0.532, 1.0), 
                       ce.ThinLens(lambda _: 10.0, 1.33, 0.8)])

params=model.init(key, ) # No inputs at runtime.
print(params)
model.apply(params, ) # Field after thin lens.
```

## PSFImager

Most systems are approximately translation invariant and can be characterized by a point spread function. For these systems the `PSFImager` is useful, combining the `OpticalSystem`, a noise model for the sensor and a so-called `reduce_fn`: 

```py
from chromatix import PSFImager
from chromatix.ops.noise import shot_noise

system = [ce.PointSource((2560, 2560), 1.0, 0.532, 1.0, 10.0, 1.33), 
          ce.ThinLens(lambda _: 10.0, 1.33, 0.8)]
model = PSFImager(system, 
                  noise_fn=shot_noise, 
                  reduce_fn=lambda x: jnp.sum(x, axis=0, keepdims=True))
params = model.init({"params": key, "noise": key}, data) # note the extra key for the noise
```

The `PSFImager` calculates the PSF, and performs a convolution with the supplied data to generate the image made by this system. The `reduce_fn` defines how the batch is processed before the noise is added. This is useful when imaging 3D fields: we want to first add all the components of the field along the optical axis, and only then add the sensor noise. It offers access to the output field, psf, and ofcourse the generated generated image:

```py
psf = model.apply(params, method=model.psf, rngs={"noise": key})
output_field = model.apply(params, method=model.output_field)
image = model.apply(params, data)
```

